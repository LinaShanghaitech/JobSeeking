## 常用算法整理

### 排序查找
#### 排序  
- [x] 冒泡排序
- [x] 选择排序
- [x] 插入排序
- [x] 归并排序
- [x] 快速排序

#### 查找
- [x] 顺序查找  
- [x] 二分查找
- [x] parition

#### 字符串
- [x] 句子反转 
- [x] 回文串  
- [x] 最长不重复子串    

### 数据结构  
#### 二叉树  
- [ ] 打印  
  - [x] 递归 
  - [ ] 非递归  
- [x] 重建
- [x] 深度  
- [x] 提供前序中序给后序
#### 二叉搜索树  
- [ ] 判断  


#### 链表
- [ ] 链表反转
  - [x] 一般实现
  - [x] 递归实现
- [x] 链表合并  
- [x] 链表交点
- [x] 链表是否包含环


####  堆
- [ ] 堆排序  
- [ ] 基本理解 

####  栈和队列
- [x] 栈  
- [x] 队列

### 动态规划
- [ ] 硬币找零  
- [ ] 字符串相似度  
  - [ ] 字符串匹配
  - [ ] 最长公共子串    
- [ ] 最长回文串  
- [ ] 背包问题  

### 贪心算法
- [ ]   

### 分治算法
- [ ] 


### 要点
#### 概览  
- [ ] 时间复杂度: 递归/非递归/增长次数 => 最优/最差/平均
- [ ] 基础数据结构: 线性/图/树/集合 
- [ ] 暴力求解: 排序/字符串/穷举/BFS/DFS  
- [ ] 减治解法: 排序/排列组合/二叉树  
- [ ] 分治解法: 排序(快排)/大树  
- [ ] 变治解法: 平衡树/堆及堆排序/化简  
- [ ] 动态规划: 背包问题/BST/最短路径
- [ ] 时间/空间复杂度: 散列/B树
- [ ]  P/NP/回溯/分支界限

#### 编程练习
- [ ] 查找/排序联系(leetcode) => 二分查找/归并排序/快排
- [ ] 堆/树/链表 => 应用(leetcode/牛客网)
- [ ] 面试经典题目 => 剑指offer68题


#### 常考算法题
- [ ] 旋转数组的查找  
- [ ] 计算矩阵的重叠部分  
- [ ] 第k大的数 topK个数  
- [ ] 给一个数组，里面只有一个数只出现一次，其余均出现两次，找出那个数  
- [ ] 二叉树中序遍历的非递归实现  
- [ ] 二叉树层次遍历 
- [ ] 字符串的所有排列  
- [ ] 一个人从原点出发，可以往左走可以往右走，每次走的步数递增1，问能不能到达一个位置x？如果能，给出走的步数最少的方案？ 
    [参考答案](https://blog.csdn.net/fuxuemingzhu/article/details/84556932)
- [ ] 输入一个文件，等概率输出某一行，只能顺序遍历  
- [ ] 求最长上升子序列  
- [ ] 有两个字符串，你只可以进行删除操作，问你最少进行多少次操作可以使两个字符串相等。 (头条)　　
- [ ] 给你一个二叉查找树，还有一个数K。如果能找到，就返回节点，如果找不到，就返回空 (头条)　　
- [ ] 递归有什么缺点:当递归层数很多的时候，容易造成内存溢出  
- [ ] 有M个有序链表（从大到小）。现在我们要取出前K大的元素:
      ```
        我们应该把M个链表的头节点做成一个大小为M的最大堆，每次取出堆中最大的节点，然后将这个节点的后序节点放进来，重新对堆进行排序。
       时间复杂度，每次需要 O(logm)O(logm)，需要k次，那么总的时间复杂度为 O(klogm)O(klogm) 。空间复杂度为 O(m)O(m)
       堆的时候时间复杂度，O(mlogm)O(mlogm)，那总的时间复杂度应该为O((k+m)logm)O((k+m)logm) 。
       ```
- [ ] 求二叉树节点间的最长距离, 不一定过根节点 
- [ ] 写个快排 
- [ ] 给定无序的数组，求出 连续相邻的子数组中最小值乘以长度 使得值最大的连续数组, 输出二叉树每一行最左边的元素  
- [ ] 将n个有序链表合并成一个链表(leetcode23)  
- [ ] 寻找最小连续子序列，返回序列和，以及子序列起始索引和结束索引




